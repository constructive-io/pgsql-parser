{
  "plpgsql_varprops-1.sql": "-- CONSTANT\n\ndo $$\ndeclare x constant int := 42;\nbegin\n  raise notice 'x = %', x;\nend$$",
  "plpgsql_varprops-2.sql": "-- initializer expressions\n\ndo $$\ndeclare x int := sin(0);\nbegin\n  raise notice 'x = %', x;\nend$$",
  "plpgsql_varprops-3.sql": "do $$\ndeclare x int := 1/0;  -- fail\nbegin\n  raise notice 'x = %', x;\nend$$",
  "plpgsql_varprops-4.sql": "do $$\ndeclare x bigint[] := array[1,3,5];\nbegin\n  raise notice 'x = %', x;\nend$$",
  "plpgsql_varprops-5.sql": "do $$\ndeclare x record := row(1,2,3);\nbegin\n  raise notice 'x = %', x;\nend$$",
  "plpgsql_varprops-6.sql": "do $$\ndeclare x var_record := row(1,2);\nbegin\n  raise notice 'x = %', x;\nend$$",
  "plpgsql_varprops-7.sql": "do $$\ndeclare x int not null := 42;\nbegin\n  raise notice 'x = %', x;\n  x := null;  -- fail\nend$$",
  "plpgsql_varprops-8.sql": "do $$\ndeclare x int not null := null;  -- fail\nbegin\n  raise notice 'x = %', x;\nend$$",
  "plpgsql_varprops-9.sql": "do $$\ndeclare x record not null := row(42);\nbegin\n  raise notice 'x = %', x;\n  x := row(null);  -- ok\n  raise notice 'x = %', x;\n  x := null;  -- fail\nend$$",
  "plpgsql_varprops-10.sql": "do $$\ndeclare x record not null := null;  -- fail\nbegin\n  raise notice 'x = %', x;\nend$$",
  "plpgsql_varprops-11.sql": "do $$\ndeclare x var_record not null := row(41,42);\nbegin\n  raise notice 'x = %', x;\n  x := row(null,null);  -- ok\n  raise notice 'x = %', x;\n  x := null;  -- fail\nend$$",
  "plpgsql_varprops-12.sql": "do $$\ndeclare x var_record not null := null;  -- fail\nbegin\n  raise notice 'x = %', x;\nend$$",
  "plpgsql_varprops-13.sql": "-- Check that variables are reinitialized on block re-entry.\n\ndo $$\nbegin\n  for i in 1..3 loop\n    declare\n      x int;\n      y int := i;\n      r record;\n      c var_record;\n    begin\n      if i = 1 then\n        x := 42;\n        r := row(i, i+1);\n        c := row(i, i+1);\n      end if;\n      raise notice 'x = %', x;\n      raise notice 'y = %', y;\n      raise notice 'r = %', r;\n      raise notice 'c = %', c;\n    end;\n  end loop;\nend$$",
  "plpgsql_varprops-14.sql": "-- Check enforcement of domain constraints during initialization\n\ndo $$\ndeclare x int_nn;  -- fail\nbegin\n  raise notice 'x = %', x;\nend$$",
  "plpgsql_varprops-15.sql": "do $$\ndeclare x int_nn := null;  -- fail\nbegin\n  raise notice 'x = %', x;\nend$$",
  "plpgsql_varprops-16.sql": "do $$\ndeclare x int_nn := 42;\nbegin\n  raise notice 'x = %', x;\n  x := null;  -- fail\nend$$",
  "plpgsql_varprops-17.sql": "do $$\ndeclare x var_record_nn;  -- fail\nbegin\n  raise notice 'x = %', x;\nend$$",
  "plpgsql_varprops-18.sql": "do $$\ndeclare x var_record_nn := null;  -- fail\nbegin\n  raise notice 'x = %', x;\nend$$",
  "plpgsql_varprops-19.sql": "do $$\ndeclare x var_record_nn := row(1,2);\nbegin\n  raise notice 'x = %', x;\n  x := row(null,null);  -- ok\n  x := null;  -- fail\nend$$",
  "plpgsql_varprops-20.sql": "do $$\ndeclare x var_record_colnn;  -- fail\nbegin\n  raise notice 'x = %', x;\nend$$",
  "plpgsql_varprops-21.sql": "do $$\ndeclare x var_record_colnn := null;  -- fail\nbegin\n  raise notice 'x = %', x;\nend$$",
  "plpgsql_varprops-22.sql": "do $$\ndeclare x var_record_colnn := row(1,null);  -- fail\nbegin\n  raise notice 'x = %', x;\nend$$",
  "plpgsql_varprops-23.sql": "do $$\ndeclare x var_record_colnn := row(1,2);\nbegin\n  raise notice 'x = %', x;\n  x := null;  -- fail\nend$$",
  "plpgsql_varprops-24.sql": "do $$\ndeclare x var_record_colnn := row(1,2);\nbegin\n  raise notice 'x = %', x;\n  x := row(null,null);  -- fail\nend$$",
  "plpgsql_trigger-1.sql": "create function testtr_trigger() returns trigger language plpgsql as\n$$begin\n  raise notice 'tg_op = %', tg_op;\n  raise notice 'old(%) = %', old.a, row(old.*);\n  raise notice 'new(%) = %', new.a, row(new.*);\n  if (tg_op = 'DELETE') then\n    return old;\n  else\n    return new;\n  end if;\nend$$",
  "plpgsql_trap-1.sql": "--\n-- Test error trapping\n--\n\ncreate function trap_zero_divide(int) returns int as $$\ndeclare x int;\n\tsx smallint;\nbegin\n\tbegin\t-- start a subtransaction\n\t\traise notice 'should see this';\n\t\tx := 100 / $1;\n\t\traise notice 'should see this only if % <> 0', $1;\n\t\tsx := $1;\n\t\traise notice 'should see this only if % fits in smallint', $1;\n\t\tif $1 < 0 then\n\t\t\traise exception '% is less than zero', $1;\n\t\tend if;\n\texception\n\t\twhen division_by_zero then\n\t\t\traise notice 'caught division_by_zero';\n\t\t\tx := -1;\n\t\twhen NUMERIC_VALUE_OUT_OF_RANGE then\n\t\t\traise notice 'caught numeric_value_out_of_range';\n\t\t\tx := -2;\n\tend;\n\treturn x;\nend$$ language plpgsql",
  "plpgsql_trap-2.sql": "create function trap_matching_test(int) returns int as $$\ndeclare x int;\n\tsx smallint;\n\ty int;\nbegin\n\tbegin\t-- start a subtransaction\n\t\tx := 100 / $1;\n\t\tsx := $1;\n\t\tselect into y data from match_source where id =\n\t\t\t(select id from match_source b where ten = $1);\n\texception\n\t\twhen data_exception then  -- category match\n\t\t\traise notice 'caught data_exception';\n\t\t\tx := -1;\n\t\twhen NUMERIC_VALUE_OUT_OF_RANGE OR CARDINALITY_VIOLATION then\n\t\t\traise notice 'caught numeric_value_out_of_range or cardinality_violation';\n\t\t\tx := -2;\n\tend;\n\treturn x;\nend$$ language plpgsql",
  "plpgsql_trap-3.sql": "create function subxact_rollback_semantics() returns int as $$\ndeclare x int;\nbegin\n  x := 1;\n  insert into foo values(x);\n  begin\n    x := x + 1;\n    insert into foo values(x);\n    raise exception 'inner';\n  exception\n    when others then\n      x := x * 10;\n  end;\n  insert into foo values(x);\n  return x;\nend$$ language plpgsql",
  "plpgsql_trap-4.sql": "create function trap_timeout() returns void as $$\nbegin\n  declare x int;\n  begin\n    -- we assume this will take longer than 1 second:\n    select count(*) into x from generate_series(1, 1_000_000_000_000);\n  exception\n    when others then\n      raise notice 'caught others?';\n    when query_canceled then\n      raise notice 'nyeah nyeah, can''t stop me';\n  end;\n  -- Abort transaction to abandon the statement_timeout setting.  Otherwise,\n  -- the next top-level statement would be vulnerable to the timeout.\n  raise exception 'end of function';\nend$$ language plpgsql",
  "plpgsql_trap-5.sql": "-- Test for pass-by-ref values being stored in proper context\ncreate function test_variable_storage() returns text as $$\ndeclare x text;\nbegin\n  x := '1234';\n  begin\n    x := x || '5678';\n    -- force error inside subtransaction SPI context\n    perform trap_zero_divide(-100);\n  exception\n    when others then\n      x := x || '9012';\n  end;\n  return x;\nend$$ language plpgsql",
  "plpgsql_trap-6.sql": "-- fails\n\ncreate function trap_foreign_key(int) returns int as $$\nbegin\n\tbegin\t-- start a subtransaction\n\t\tinsert into leaf values($1);\n\texception\n\t\twhen foreign_key_violation then\n\t\t\traise notice 'caught foreign_key_violation';\n\t\t\treturn 0;\n\tend;\n\treturn 1;\nend$$ language plpgsql",
  "plpgsql_trap-7.sql": "create function trap_foreign_key_2() returns int as $$\nbegin\n\tbegin\t-- start a subtransaction\n\t\tset constraints all immediate;\n\texception\n\t\twhen foreign_key_violation then\n\t\t\traise notice 'caught foreign_key_violation';\n\t\t\treturn 0;\n\tend;\n\treturn 1;\nend$$ language plpgsql",
  "plpgsql_transaction-1.sql": "CREATE PROCEDURE transaction_test1(x int, y text)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    FOR i IN 0..x LOOP\n        INSERT INTO test1 (a, b) VALUES (i, y);\n        IF i % 2 = 0 THEN\n            COMMIT;\n        ELSE\n            ROLLBACK;\n        END IF;\n    END LOOP;\nEND\n$$",
  "plpgsql_transaction-2.sql": "DO\nLANGUAGE plpgsql\n$$\nBEGIN\n    FOR i IN 0..9 LOOP\n        INSERT INTO test1 (a) VALUES (i);\n        IF i % 2 = 0 THEN\n            COMMIT;\n        ELSE\n            ROLLBACK;\n        END IF;\n    END LOOP;\nEND\n$$",
  "plpgsql_transaction-3.sql": "DO LANGUAGE plpgsql $$ BEGIN COMMIT; END $$",
  "plpgsql_transaction-4.sql": "-- not allowed in a function\nCREATE FUNCTION transaction_test2() RETURNS int\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    FOR i IN 0..9 LOOP\n        INSERT INTO test1 (a) VALUES (i);\n        IF i % 2 = 0 THEN\n            COMMIT;\n        ELSE\n            ROLLBACK;\n        END IF;\n    END LOOP;\n    RETURN 1;\nEND\n$$",
  "plpgsql_transaction-5.sql": "-- also not allowed if procedure is called from a function\nCREATE FUNCTION transaction_test3() RETURNS int\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    CALL transaction_test1(9, 'error');\n    RETURN 1;\nEND;\n$$",
  "plpgsql_transaction-6.sql": "-- DO block inside function\nCREATE FUNCTION transaction_test4() RETURNS int\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    EXECUTE 'DO LANGUAGE plpgsql $x$ BEGIN COMMIT; END $x$';\n    RETURN 1;\nEND;\n$$",
  "plpgsql_transaction-7.sql": "-- proconfig settings currently disallow transaction statements\nCREATE PROCEDURE transaction_test5()\nLANGUAGE plpgsql\nSET work_mem = 555\nAS $$\nBEGIN\n    COMMIT;\nEND;\n$$",
  "plpgsql_transaction-8.sql": "-- SECURITY DEFINER currently disallow transaction statements\nCREATE PROCEDURE transaction_test5b()\nLANGUAGE plpgsql\nSECURITY DEFINER\nAS $$\nBEGIN\n    COMMIT;\nEND;\n$$",
  "plpgsql_transaction-9.sql": "-- nested procedure calls\nCREATE PROCEDURE transaction_test6(c text)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    CALL transaction_test1(9, c);\nEND;\n$$",
  "plpgsql_transaction-10.sql": "CREATE PROCEDURE transaction_test7()\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    DO 'BEGIN CALL transaction_test1(9, $x$baz$x$); END;';\nEND;\n$$",
  "plpgsql_transaction-11.sql": "CREATE PROCEDURE transaction_test8()\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    EXECUTE 'CALL transaction_test1(10, $x$baz$x$)';\nEND;\n$$",
  "plpgsql_transaction-12.sql": "DO LANGUAGE plpgsql $$\nDECLARE\n    r RECORD;\nBEGIN\n    FOR r IN SELECT * FROM test2 ORDER BY x LOOP\n        INSERT INTO test1 (a) VALUES (r.x);\n        COMMIT;\n    END LOOP;\nEND;\n$$",
  "plpgsql_transaction-13.sql": "DO LANGUAGE plpgsql $$\nDECLARE\n    r RECORD;\nBEGIN\n    FOR r IN SELECT * FROM test2 ORDER BY x LOOP\n        INSERT INTO test1 (a) VALUES (12/(r.x-2));\n        COMMIT;\n    END LOOP;\nEND;\n$$",
  "plpgsql_transaction-14.sql": "DO LANGUAGE plpgsql $$\nDECLARE\n    r RECORD;\nBEGIN\n    FOR r IN SELECT * FROM test2 ORDER BY x LOOP\n        INSERT INTO test1 (a) VALUES (r.x);\n        ROLLBACK;\n    END LOOP;\nEND;\n$$",
  "plpgsql_transaction-15.sql": "DO LANGUAGE plpgsql $$\nDECLARE\n    r RECORD;\nBEGIN\n    FOR r IN SELECT * FROM test2 ORDER BY x LOOP\n        INSERT INTO test1 (a) VALUES (r.x);\n        IF r.x % 2 = 0 THEN\n            COMMIT;\n        ELSE\n            ROLLBACK;\n        END IF;\n    END LOOP;\nEND;\n$$",
  "plpgsql_transaction-16.sql": "DO LANGUAGE plpgsql $$\nDECLARE\n    r RECORD;\nBEGIN\n    FOR r IN UPDATE test2 SET x = x * 2 RETURNING x LOOP\n        INSERT INTO test1 (a) VALUES (r.x);\n        ROLLBACK;\n    END LOOP;\nEND;\n$$",
  "plpgsql_transaction-17.sql": "DO LANGUAGE plpgsql $$\nDECLARE\n    l_cur CURSOR FOR SELECT a FROM test1 ORDER BY 1 FOR UPDATE;\nBEGIN\n    FOR r IN l_cur LOOP\n      UPDATE test1 SET b = b || ' ' || b WHERE a = r.a;\n      COMMIT;\n    END LOOP;\nEND;\n$$",
  "plpgsql_transaction-18.sql": "DO LANGUAGE plpgsql $$\nDECLARE r RECORD;\nBEGIN\n    FOR r IN SELECT a FROM test1 FOR UPDATE LOOP\n      UPDATE test1 SET b = b || ' ' || b WHERE a = r.a;\n      COMMIT;\n    END LOOP;\nEND;\n$$",
  "plpgsql_transaction-19.sql": "DO LANGUAGE plpgsql $$\nBEGIN\n    BEGIN\n        INSERT INTO test1 (a) VALUES (1);\n        COMMIT;\n        INSERT INTO test1 (a) VALUES (1/0);\n        COMMIT;\n    EXCEPTION\n        WHEN division_by_zero THEN\n            RAISE NOTICE 'caught division_by_zero';\n    END;\nEND;\n$$",
  "plpgsql_transaction-20.sql": "DO LANGUAGE plpgsql $$\nBEGIN\n    BEGIN\n        INSERT INTO test1 (a) VALUES (1);\n        ROLLBACK;\n        INSERT INTO test1 (a) VALUES (1/0);\n        ROLLBACK;\n    EXCEPTION\n        WHEN division_by_zero THEN\n            RAISE NOTICE 'caught division_by_zero';\n    END;\nEND;\n$$",
  "plpgsql_transaction-21.sql": "DO LANGUAGE plpgsql $$\nBEGIN\n    FOR i IN 1..10 LOOP\n      BEGIN\n        INSERT INTO test1 VALUES (i, 'good');\n        INSERT INTO test1 VALUES (i/0, 'bad');\n      EXCEPTION\n        WHEN division_by_zero THEN\n            INSERT INTO test1 VALUES (i, 'exception');\n            IF (i % 3) > 0 THEN COMMIT; ELSE ROLLBACK; END IF;\n      END;\n    END LOOP;\nEND;\n$$",
  "plpgsql_transaction-22.sql": "DO $$\ndeclare x text;\nbegin\n  for i in 1..3 loop\n    x := data_source(i);\n    commit;\n  end loop;\n  raise notice 'length(x) = %', length(x);\nend $$",
  "plpgsql_transaction-23.sql": "-- operations on composite types vs. internal transactions\nDO LANGUAGE plpgsql $$\ndeclare\n  c test1 := row(42, 'hello');\n  r bool;\nbegin\n  for i in 1..3 loop\n    r := c is not null;\n    raise notice 'r = %', r;\n    commit;\n  end loop;\n  for i in 1..3 loop\n    r := c is null;\n    raise notice 'r = %', r;\n    rollback;\n  end loop;\nend\n$$",
  "plpgsql_transaction-24.sql": "-- COMMIT failures\nDO LANGUAGE plpgsql $$\nBEGIN\n    CREATE TABLE test3 (y int UNIQUE DEFERRABLE INITIALLY DEFERRED);\n    COMMIT;\n    INSERT INTO test3 (y) VALUES (1);\n    COMMIT;\n    INSERT INTO test3 (y) VALUES (1);\n    INSERT INTO test3 (y) VALUES (2);\n    COMMIT;\n    INSERT INTO test3 (y) VALUES (3);  -- won't get here\nEND;\n$$",
  "plpgsql_transaction-25.sql": "-- failure while trying to persist a cursor across a transaction (bug #15703)\nCREATE PROCEDURE cursor_fail_during_commit()\n LANGUAGE plpgsql\nAS $$\n  DECLARE id int;\n  BEGIN\n    FOR id IN SELECT 1/(x-1000) FROM generate_series(1,1000) x LOOP\n        INSERT INTO test1 VALUES(id);\n        COMMIT;\n    END LOOP;\n  END;\n$$",
  "plpgsql_transaction-26.sql": "CREATE PROCEDURE cursor_fail_during_rollback()\n LANGUAGE plpgsql\nAS $$\n  DECLARE id int;\n  BEGIN\n    FOR id IN SELECT 1/(x-1000) FROM generate_series(1,1000) x LOOP\n        INSERT INTO test1 VALUES(id);\n        ROLLBACK;\n    END LOOP;\n  END;\n$$",
  "plpgsql_transaction-27.sql": "-- SET TRANSACTION\nDO LANGUAGE plpgsql $$\nBEGIN\n    PERFORM 1;\n    RAISE INFO '%', current_setting('transaction_isolation');\n    COMMIT;\n    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;\n    PERFORM 1;\n    RAISE INFO '%', current_setting('transaction_isolation');\n    COMMIT;\n    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;\n    PERFORM 1;\n    RAISE INFO '%', current_setting('transaction_isolation');\n    COMMIT;\nEND;\n$$",
  "plpgsql_transaction-28.sql": "-- error cases\nDO LANGUAGE plpgsql $$\nBEGIN\n    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;\nEND;\n$$",
  "plpgsql_transaction-29.sql": "DO LANGUAGE plpgsql $$\nBEGIN\n    SAVEPOINT foo;\nEND;\n$$",
  "plpgsql_transaction-30.sql": "DO LANGUAGE plpgsql $$\nBEGIN\n    EXECUTE 'COMMIT';\nEND;\n$$",
  "plpgsql_transaction-31.sql": "DO LANGUAGE plpgsql $$\nBEGIN\n  ROLLBACK;\n  CALL transaction_test9();\nEND\n$$",
  "plpgsql_transaction-32.sql": "CREATE PROCEDURE transaction_test9b(cnt int)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n  RAISE NOTICE 'count = %', cnt;\nEND\n$$",
  "plpgsql_transaction-33.sql": "DO $$\nBEGIN\n    CALL transaction_test9b(report_count());\n    INSERT INTO test2 VALUES(43);\n    CALL transaction_test9b(report_count());\nEND\n$$",
  "plpgsql_transaction-34.sql": "-- Test transaction in procedure with output parameters.  This uses a\n-- different portal strategy and different code paths in pquery.c.\nCREATE PROCEDURE transaction_test10a(INOUT x int)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n  x := x + 1;\n  COMMIT;\nEND;\n$$",
  "plpgsql_transaction-35.sql": "CREATE PROCEDURE transaction_test10b(INOUT x int)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n  x := x - 1;\n  ROLLBACK;\nEND;\n$$",
  "plpgsql_transaction-36.sql": "-- transaction timestamp vs. statement timestamp\nCREATE PROCEDURE transaction_test11()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n  s1 timestamp with time zone;\n  s2 timestamp with time zone;\n  s3 timestamp with time zone;\n  t1 timestamp with time zone;\n  t2 timestamp with time zone;\n  t3 timestamp with time zone;\nBEGIN\n  s1 := statement_timestamp();\n  t1 := transaction_timestamp();\n  ASSERT s1 = t1;\n  PERFORM pg_sleep(0.001);\n  COMMIT;\n  s2 := statement_timestamp();\n  t2 := transaction_timestamp();\n  ASSERT s2 = s1;\n  ASSERT t2 > t1;\n  PERFORM pg_sleep(0.001);\n  ROLLBACK;\n  s3 := statement_timestamp();\n  t3 := transaction_timestamp();\n  ASSERT s3 = s1;\n  ASSERT t3 > t2;\nEND;\n$$",
  "plpgsql_transaction-37.sql": "DO LANGUAGE plpgsql $$\nBEGIN\n    ROLLBACK;\n    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;\n    FOR i IN 0..3 LOOP\n        RAISE INFO 'transaction_isolation = %', current_setting('transaction_isolation');\n        INSERT INTO test1 (a) VALUES (i);\n        IF i % 2 = 0 THEN\n            COMMIT AND CHAIN;\n        ELSE\n            ROLLBACK AND CHAIN;\n        END IF;\n    END LOOP;\nEND\n$$",
  "plpgsql_domain-1.sql": "CREATE FUNCTION test_argresult_booltrue(x booltrue, y bool) RETURNS booltrue AS $$\nbegin\nreturn y;\nend\n$$ LANGUAGE plpgsql",
  "plpgsql_domain-2.sql": "CREATE FUNCTION test_assign_booltrue(x bool, y bool) RETURNS booltrue AS $$\ndeclare v booltrue := x;\nbegin\nv := y;\nreturn v;\nend\n$$ LANGUAGE plpgsql",
  "plpgsql_domain-3.sql": "CREATE FUNCTION test_argresult_uint2(x uint2, y int) RETURNS uint2 AS $$\nbegin\nreturn y;\nend\n$$ LANGUAGE plpgsql",
  "plpgsql_domain-4.sql": "CREATE FUNCTION test_assign_uint2(x int, y int) RETURNS uint2 AS $$\ndeclare v uint2 := x;\nbegin\nv := y;\nreturn v;\nend\n$$ LANGUAGE plpgsql",
  "plpgsql_domain-5.sql": "CREATE FUNCTION test_argresult_nnint(x nnint, y int) RETURNS nnint AS $$\nbegin\nreturn y;\nend\n$$ LANGUAGE plpgsql",
  "plpgsql_domain-6.sql": "CREATE FUNCTION test_assign_nnint(x int, y int) RETURNS nnint AS $$\ndeclare v nnint := x;\nbegin\nv := y;\nreturn v;\nend\n$$ LANGUAGE plpgsql",
  "plpgsql_domain-7.sql": "CREATE FUNCTION test_argresult_array_domain(x ordered_pair_domain)\n  RETURNS ordered_pair_domain AS $$\nbegin\nreturn x;\nend\n$$ LANGUAGE plpgsql",
  "plpgsql_domain-8.sql": "CREATE FUNCTION test_argresult_array_domain_check_violation()\n  RETURNS ordered_pair_domain AS $$\nbegin\nreturn array[2,1];\nend\n$$ LANGUAGE plpgsql",
  "plpgsql_domain-9.sql": "CREATE FUNCTION test_assign_ordered_pair_domain(x int, y int, z int) RETURNS ordered_pair_domain AS $$\ndeclare v ordered_pair_domain := array[x, y];\nbegin\nv[2] := z;\nreturn v;\nend\n$$ LANGUAGE plpgsql",
  "plpgsql_domain-10.sql": "--\n-- Arrays of domains\n--\n\nCREATE FUNCTION test_read_uint2_array(x uint2[]) RETURNS uint2 AS $$\nbegin\nreturn x[1];\nend\n$$ LANGUAGE plpgsql",
  "plpgsql_domain-11.sql": "CREATE FUNCTION test_build_uint2_array(x int2) RETURNS uint2[] AS $$\nbegin\nreturn array[x, x];\nend\n$$ LANGUAGE plpgsql",
  "plpgsql_domain-12.sql": "-- fail\n\nCREATE FUNCTION test_argresult_domain_array(x integer[])\n  RETURNS ordered_pair_domain[] AS $$\nbegin\nreturn array[x::ordered_pair_domain, x::ordered_pair_domain];\nend\n$$ LANGUAGE plpgsql",
  "plpgsql_domain-13.sql": "-- fail\n\nCREATE FUNCTION test_argresult_domain_array2(x ordered_pair_domain)\n  RETURNS integer AS $$\nbegin\nreturn x[1];\nend\n$$ LANGUAGE plpgsql",
  "plpgsql_domain-14.sql": "-- fail\n\nCREATE FUNCTION test_argresult_array_domain_array(x ordered_pair_domain[])\n  RETURNS ordered_pair_domain AS $$\nbegin\nreturn x[1];\nend\n$$ LANGUAGE plpgsql",
  "plpgsql_domain-15.sql": "CREATE FUNCTION test_result_nnint_container(x int, y int)\n  RETURNS nnint_container AS $$\nbegin\nreturn row(x, y)::nnint_container;\nend\n$$ LANGUAGE plpgsql",
  "plpgsql_domain-16.sql": "CREATE FUNCTION read_ordered_named_pair(p ordered_named_pair) RETURNS integer AS $$\nbegin\nreturn p.i + p.j;\nend\n$$ LANGUAGE plpgsql",
  "plpgsql_domain-17.sql": "-- fail\n\nCREATE FUNCTION build_ordered_named_pair(i int, j int) RETURNS ordered_named_pair AS $$\nbegin\nreturn row(i, j);\nend\n$$ LANGUAGE plpgsql",
  "plpgsql_domain-18.sql": "CREATE FUNCTION build_ordered_named_pairs(i int, j int) RETURNS ordered_named_pair[] AS $$\nbegin\nreturn array[row(i, j), row(i, j+1)];\nend\n$$ LANGUAGE plpgsql",
  "plpgsql_domain-19.sql": "-- fail\n\nCREATE FUNCTION test_assign_ordered_named_pairs(x int, y int, z int)\n  RETURNS ordered_named_pair[] AS $$\ndeclare v ordered_named_pair[] := array[row(x, y)];\nbegin\n-- ideally this would work, but it doesn't yet:\n-- v[1].j := z;\nreturn v;\nend\n$$ LANGUAGE plpgsql",
  "plpgsql_deparser_fixes-1.sql": "-- Fixtures to test deparser fixes from constructive-db PR #229\n-- These exercise: PERFORM, INTO clause placement, record field qualification, RETURN handling\n\n-- Test 1: PERFORM statement (parser stores as SELECT, deparser must strip SELECT)\nCREATE FUNCTION test_perform_basic() RETURNS trigger\nLANGUAGE plpgsql AS $$\nBEGIN\n  PERFORM pg_notify('test_channel', 'message');\n  RETURN NEW;\nEND$$",
  "plpgsql_deparser_fixes-2.sql": "-- Test 2: PERFORM with function call and arguments\nCREATE FUNCTION test_perform_with_args() RETURNS trigger\nLANGUAGE plpgsql AS $$\nBEGIN\n  IF (TG_OP = 'INSERT' OR TG_OP = 'UPDATE') THEN\n    PERFORM pg_notify(TG_ARGV[0], to_json(NEW)::text);\n    RETURN NEW;\n  END IF;\n  IF (TG_OP = 'DELETE') THEN\n    PERFORM pg_notify(TG_ARGV[0], to_json(OLD)::text);\n    RETURN OLD;\n  END IF;\n  RETURN NULL;\nEND$$",
  "plpgsql_deparser_fixes-3.sql": "-- Test 3: INTO clause with record field target (recfield qualification)\nCREATE FUNCTION test_into_record_field() RETURNS trigger\nLANGUAGE plpgsql AS $$\nBEGIN\n  SELECT\n    NEW.is_approved IS TRUE\n      AND NEW.is_verified IS TRUE\n      AND NEW.is_disabled IS FALSE INTO NEW.is_active;\n  RETURN NEW;\nEND$$",
  "plpgsql_deparser_fixes-4.sql": "-- Test 4: INTO clause with subquery (depth-aware scanner must skip nested FROM)\nCREATE FUNCTION test_into_with_subquery() RETURNS trigger\nLANGUAGE plpgsql AS $$\nDECLARE\n  result_value int;\nBEGIN\n  SELECT count(*) INTO result_value\n  FROM (SELECT id FROM users WHERE id = NEW.user_id) sub;\n  RETURN NEW;\nEND$$",
  "plpgsql_deparser_fixes-5.sql": "-- Test 5: INTO clause with multiple record fields\nCREATE FUNCTION test_into_multiple_fields() RETURNS trigger\nLANGUAGE plpgsql AS $$\nBEGIN\n  SELECT is_active, is_verified INTO NEW.is_active, NEW.is_verified\n  FROM users WHERE id = NEW.user_id;\n  RETURN NEW;\nEND$$",
  "plpgsql_deparser_fixes-6.sql": "-- Test 6: SETOF function with RETURN QUERY and bare RETURN\nCREATE FUNCTION test_setof_return_query(p_limit int)\nRETURNS SETOF int\nLANGUAGE plpgsql AS $$\nBEGIN\n  RETURN QUERY SELECT generate_series(1, p_limit);\n  RETURN;\nEND$$",
  "plpgsql_deparser_fixes-7.sql": "-- Test 7: SETOF function with RETURN NEXT\nCREATE FUNCTION test_setof_return_next(p_count int)\nRETURNS SETOF text\nLANGUAGE plpgsql AS $$\nDECLARE\n  i int;\nBEGIN\n  FOR i IN 1..p_count LOOP\n    RETURN NEXT 'item_' || i::text;\n  END LOOP;\n  RETURN;\nEND$$",
  "plpgsql_deparser_fixes-8.sql": "-- Test 8: Void function with bare RETURN\nCREATE FUNCTION test_void_function(p_value text)\nRETURNS void\nLANGUAGE plpgsql AS $$\nBEGIN\n  RAISE NOTICE 'Value: %', p_value;\n  RETURN;\nEND$$",
  "plpgsql_deparser_fixes-9.sql": "-- Test 9: Scalar function with RETURN NULL\nCREATE FUNCTION test_scalar_return_null()\nRETURNS int\nLANGUAGE plpgsql AS $$\nBEGIN\n  RETURN NULL;\nEND$$",
  "plpgsql_deparser_fixes-10.sql": "-- Test 10: Scalar function with conditional RETURN\nCREATE FUNCTION test_scalar_conditional(p_value int)\nRETURNS int\nLANGUAGE plpgsql AS $$\nBEGIN\n  IF p_value > 0 THEN\n    RETURN p_value * 2;\n  END IF;\n  RETURN NULL;\nEND$$",
  "plpgsql_deparser_fixes-11.sql": "-- Test 11: OUT parameter function with bare RETURN\nCREATE FUNCTION test_out_params(OUT ok boolean, OUT message text)\nLANGUAGE plpgsql AS $$\nBEGIN\n  ok := true;\n  message := 'success';\n  RETURN;\nEND$$",
  "plpgsql_deparser_fixes-12.sql": "-- Test 12: RETURNS TABLE function with RETURN QUERY\nCREATE FUNCTION test_returns_table(p_prefix text)\nRETURNS TABLE(id int, name text)\nLANGUAGE plpgsql AS $$\nBEGIN\n  RETURN QUERY SELECT 1, p_prefix || '_one';\n  RETURN QUERY SELECT 2, p_prefix || '_two';\n  RETURN;\nEND$$",
  "plpgsql_deparser_fixes-13.sql": "-- Test 13: Trigger function with complex logic\nCREATE FUNCTION test_trigger_complex() RETURNS trigger\nLANGUAGE plpgsql AS $$\nDECLARE\n  defaults_record record;\n  bit_len int;\nBEGIN\n  bit_len := bit_length(NEW.permissions);\n  \n  SELECT * INTO defaults_record\n  FROM permission_defaults AS t\n  LIMIT 1;\n  \n  IF found THEN\n    NEW.is_approved := defaults_record.is_approved;\n    NEW.is_verified := defaults_record.is_verified;\n  END IF;\n  \n  IF NEW.is_owner IS TRUE THEN\n    NEW.is_admin := true;\n    NEW.is_approved := true;\n    NEW.is_verified := true;\n  END IF;\n  \n  SELECT\n    NEW.is_approved IS TRUE\n      AND NEW.is_verified IS TRUE\n      AND NEW.is_disabled IS FALSE INTO NEW.is_active;\n  \n  RETURN NEW;\nEND$$",
  "plpgsql_deparser_fixes-14.sql": "-- Test 14: Procedure (implicit void return)\nCREATE PROCEDURE test_procedure(p_message text)\nLANGUAGE plpgsql AS $$\nBEGIN\n  RAISE NOTICE '%', p_message;\nEND$$",
  "plpgsql_control-1.sql": "--\n-- Tests for PL/pgSQL control structures\n--\n\n-- integer FOR loop\n\ndo $$\nbegin\n  -- basic case\n  for i in 1..3 loop\n    raise notice '1..3: i = %', i;\n  end loop;\n  -- with BY, end matches exactly\n  for i in 1..10 by 3 loop\n    raise notice '1..10 by 3: i = %', i;\n  end loop;\n  -- with BY, end does not match\n  for i in 1..11 by 3 loop\n    raise notice '1..11 by 3: i = %', i;\n  end loop;\n  -- zero iterations\n  for i in 1..0 by 3 loop\n    raise notice '1..0 by 3: i = %', i;\n  end loop;\n  -- REVERSE\n  for i in reverse 10..0 by 3 loop\n    raise notice 'reverse 10..0 by 3: i = %', i;\n  end loop;\n  -- potential overflow\n  for i in 2147483620..2147483647 by 10 loop\n    raise notice '2147483620..2147483647 by 10: i = %', i;\n  end loop;\n  -- potential overflow, reverse direction\n  for i in reverse -2147483620..-2147483647 by 10 loop\n    raise notice 'reverse -2147483620..-2147483647 by 10: i = %', i;\n  end loop;\nend$$",
  "plpgsql_control-2.sql": "-- BY can't be zero or negative\ndo $$\nbegin\n  for i in 1..3 by 0 loop\n    raise notice '1..3 by 0: i = %', i;\n  end loop;\nend$$",
  "plpgsql_control-3.sql": "do $$\nbegin\n  for i in 1..3 by -1 loop\n    raise notice '1..3 by -1: i = %', i;\n  end loop;\nend$$",
  "plpgsql_control-4.sql": "do $$\nbegin\n  for i in reverse 1..3 by -1 loop\n    raise notice 'reverse 1..3 by -1: i = %', i;\n  end loop;\nend$$",
  "plpgsql_control-5.sql": "create function continue_test1() returns void as $$\ndeclare _i integer = 0; _r record;\nbegin\n  raise notice '---1---';\n  loop\n    _i := _i + 1;\n    raise notice '%', _i;\n    continue when _i < 10;\n    exit;\n  end loop;\n\n  raise notice '---2---';\n  <<lbl>>\n  loop\n    _i := _i - 1;\n    loop\n      raise notice '%', _i;\n      continue lbl when _i > 0;\n      exit lbl;\n    end loop;\n  end loop;\n\n  raise notice '---3---';\n  <<the_loop>>\n  while _i < 10 loop\n    _i := _i + 1;\n    continue the_loop when _i % 2 = 0;\n    raise notice '%', _i;\n  end loop;\n\n  raise notice '---4---';\n  for _i in 1..10 loop\n    begin\n      -- applies to outer loop, not the nested begin block\n      continue when _i < 5;\n      raise notice '%', _i;\n    end;\n  end loop;\n\n  raise notice '---5---';\n  for _r in select * from conttesttbl loop\n    continue when _r.v <= 20;\n    raise notice '%', _r.v;\n  end loop;\n\n  raise notice '---6---';\n  for _r in execute 'select * from conttesttbl' loop\n    continue when _r.v <= 20;\n    raise notice '%', _r.v;\n  end loop;\n\n  raise notice '---7---';\n  <<looplabel>>\n  for _i in 1..3 loop\n    continue looplabel when _i = 2;\n    raise notice '%', _i;\n  end loop;\n\n  raise notice '---8---';\n  _i := 1;\n  while _i <= 3 loop\n    raise notice '%', _i;\n    _i := _i + 1;\n    continue when _i = 3;\n  end loop;\n\n  raise notice '---9---';\n  for _r in select * from conttesttbl order by v limit 1 loop\n    raise notice '%', _r.v;\n    continue;\n  end loop;\n\n  raise notice '---10---';\n  for _r in execute 'select * from conttesttbl order by v limit 1' loop\n    raise notice '%', _r.v;\n    continue;\n  end loop;\n\n  raise notice '---11---';\n  <<outerlooplabel>>\n  for _i in 1..2 loop\n    raise notice 'outer %', _i;\n    <<innerlooplabel>>\n    for _j in 1..3 loop\n      continue outerlooplabel when _j = 2;\n      raise notice 'inner %', _j;\n    end loop;\n  end loop;\nend; $$ language plpgsql",
  "plpgsql_control-6.sql": "-- On the other hand, EXIT *can* reference the label of a named block\ncreate function exit_block1() returns void as $$\nbegin\n    <<begin_block1>>\n    begin\n        loop\n            exit begin_block1;\n            raise exception 'should not get here';\n        end loop;\n    end;\nend;\n$$ language plpgsql",
  "plpgsql_control-7.sql": "-- verbose end block and end loop\ncreate function end_label1() returns void as $$\n<<blbl>>\nbegin\n  <<flbl1>>\n  for i in 1 .. 10 loop\n    raise notice 'i = %', i;\n    exit flbl1;\n  end loop flbl1;\n  <<flbl2>>\n  for j in 1 .. 10 loop\n    raise notice 'j = %', j;\n    exit flbl2;\n  end loop;\nend blbl;\n$$ language plpgsql",
  "plpgsql_control-8.sql": "-- unlabeled exit matches no blocks\ndo $$\nbegin\nfor i in 1..10 loop\n  <<innerblock>>\n  begin\n    begin  -- unlabeled block\n      exit;\n      raise notice 'should not get here';\n    end;\n    raise notice 'should not get here, either';\n  end;\n  raise notice 'nor here';\nend loop;\nraise notice 'should get here';\nend$$",
  "plpgsql_control-9.sql": "-- check exit out of an unlabeled block to a labeled one\ndo $$\n<<outerblock>>\nbegin\n  <<innerblock>>\n  begin\n    <<moreinnerblock>>\n    begin\n      begin  -- unlabeled block\n        exit innerblock;\n        raise notice 'should not get here';\n      end;\n      raise notice 'should not get here, either';\n    end;\n    raise notice 'nor here';\n  end;\n  raise notice 'should get here';\nend$$",
  "plpgsql_control-10.sql": "-- check exit out of outermost block\ndo $$\n<<outerblock>>\nbegin\n  <<innerblock>>\n  begin\n    exit outerblock;\n    raise notice 'should not get here';\n  end;\n  raise notice 'should not get here, either';\nend$$",
  "plpgsql_control-11.sql": "-- unlabeled exit does match a while loop\ndo $$\nbegin\n  <<outermostwhile>>\n  while 1 > 0 loop\n    <<outerwhile>>\n    while 1 > 0 loop\n      <<innerwhile>>\n      while 1 > 0 loop\n        exit;\n        raise notice 'should not get here';\n      end loop;\n      raise notice 'should get here';\n      exit outermostwhile;\n      raise notice 'should not get here, either';\n    end loop;\n    raise notice 'nor here';\n  end loop;\n  raise notice 'should get here, too';\nend$$",
  "plpgsql_control-12.sql": "-- check exit out of an unlabeled while to a labeled one\ndo $$\nbegin\n  <<outerwhile>>\n  while 1 > 0 loop\n    while 1 > 0 loop\n      exit outerwhile;\n      raise notice 'should not get here';\n    end loop;\n    raise notice 'should not get here, either';\n  end loop;\n  raise notice 'should get here';\nend$$",
  "plpgsql_control-13.sql": "-- continue to an outer while\ndo $$\ndeclare i int := 0;\nbegin\n  <<outermostwhile>>\n  while i < 2 loop\n    raise notice 'outermostwhile, i = %', i;\n    i := i + 1;\n    <<outerwhile>>\n    while 1 > 0 loop\n      <<innerwhile>>\n      while 1 > 0 loop\n        continue outermostwhile;\n        raise notice 'should not get here';\n      end loop;\n      raise notice 'should not get here, either';\n    end loop;\n    raise notice 'nor here';\n  end loop;\n  raise notice 'out of outermostwhile, i = %', i;\nend$$",
  "plpgsql_control-14.sql": "-- return out of a while\ncreate function return_from_while() returns int language plpgsql as $$\ndeclare i int := 0;\nbegin\n  while i < 10 loop\n    if i > 2 then\n      return i;\n    end if;\n    i := i + 1;\n  end loop;\n  return null;\nend$$",
  "plpgsql_control-15.sql": "-- using list of scalars in fori and fore stmts\ncreate function for_vect() returns void as $proc$\n<<lbl>>declare a integer; b varchar; c varchar; r record;\nbegin\n  -- fori\n  for i in 1 .. 3 loop\n    raise notice '%', i;\n  end loop;\n  -- fore with record var\n  for r in select gs as aa, 'BB' as bb, 'CC' as cc from generate_series(1,4) gs loop\n    raise notice '% % %', r.aa, r.bb, r.cc;\n  end loop;\n  -- fore with single scalar\n  for a in select gs from generate_series(1,4) gs loop\n    raise notice '%', a;\n  end loop;\n  -- fore with multiple scalars\n  for a,b,c in select gs, 'BB','CC' from generate_series(1,4) gs loop\n    raise notice '% % %', a, b, c;\n  end loop;\n  -- using qualified names in fors, fore is enabled, disabled only for fori\n  for lbl.a, lbl.b, lbl.c in execute $$select gs, 'bb','cc' from generate_series(1,4) gs$$ loop\n    raise notice '% % %', a, b, c;\n  end loop;\nend;\n$proc$ language plpgsql",
  "plpgsql_control-16.sql": "-- CASE statement\n\ncreate or replace function case_test(bigint) returns text as $$\ndeclare a int = 10;\n        b int = 1;\nbegin\n  case $1\n    when 1 then\n      return 'one';\n    when 2 then\n      return 'two';\n    when 3,4,3+5 then\n      return 'three, four or eight';\n    when a then\n      return 'ten';\n    when a+b, a+b+1 then\n      return 'eleven, twelve';\n  end case;\nend;\n$$ language plpgsql immutable",
  "plpgsql_control-17.sql": "-- fails\n\ncreate or replace function catch() returns void as $$\nbegin\n  raise notice '%', case_test(6);\nexception\n  when case_not_found then\n    raise notice 'caught case_not_found % %', SQLSTATE, SQLERRM;\nend\n$$ language plpgsql",
  "plpgsql_control-18.sql": "-- test the searched variant too, as well as ELSE\ncreate or replace function case_test(bigint) returns text as $$\ndeclare a int = 10;\nbegin\n  case\n    when $1 = 1 then\n      return 'one';\n    when $1 = a + 2 then\n      return 'twelve';\n    else\n      return 'other';\n  end case;\nend;\n$$ language plpgsql immutable",
  "plpgsql_control-19.sql": "-- test line comment between WHEN and THEN\ncreate or replace function case_comment(int) returns text as $$\nbegin\n  case $1\n    when 1 -- comment before THEN\n      then return 'one';\n    else\n      return 'other';\n  end case;\nend;\n$$ language plpgsql immutable",
  "plpgsql_call-1.sql": "--\n-- Tests for procedures / CALL syntax\n--\n\nCREATE PROCEDURE test_proc1()\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    NULL;\nEND;\n$$",
  "plpgsql_call-2.sql": "-- error: can't return non-NULL\nCREATE PROCEDURE test_proc2()\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    RETURN 5;\nEND;\n$$",
  "plpgsql_call-3.sql": "CREATE PROCEDURE test_proc3(x int)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    INSERT INTO test1 VALUES (x);\nEND;\n$$",
  "plpgsql_call-4.sql": "-- Check that plan revalidation doesn't prevent setting transaction properties\n-- (bug #18059).  This test must include the first temp-object creation in\n-- this script, or it won't exercise the bug scenario.  Hence we put it early.\nCREATE PROCEDURE test_proc3a()\nLANGUAGE plpgsql\nAS $$\nBEGIN\n   COMMIT;\n   SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;\n   RAISE NOTICE 'done';\nEND;\n$$",
  "plpgsql_call-5.sql": "CREATE PROCEDURE test_proc4(y int)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    CALL test_proc3(y);\n    CALL test_proc3($1);\nEND;\n$$",
  "plpgsql_call-6.sql": "-- output arguments\n\nCREATE PROCEDURE test_proc5(INOUT a text)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    a := a || '+' || a;\nEND;\n$$",
  "plpgsql_call-7.sql": "CREATE PROCEDURE test_proc6(a int, INOUT b int, INOUT c int)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    b := b * a;\n    c := c * a;\nEND;\n$$",
  "plpgsql_call-8.sql": "DO\nLANGUAGE plpgsql\n$$\nDECLARE\n    x int := 3;\n    y int := 4;\nBEGIN\n    CALL test_proc6(2, x, y);\n    RAISE INFO 'x = %, y = %', x, y;\n    CALL test_proc6(2, c => y, b => x);\n    RAISE INFO 'x = %, y = %', x, y;\nEND;\n$$",
  "plpgsql_call-9.sql": "DO\nLANGUAGE plpgsql\n$$\nDECLARE\n    x int := 3;\n    y int := 4;\nBEGIN\n    CALL test_proc6(2, x + 1, y);  -- error\n    RAISE INFO 'x = %, y = %', x, y;\nEND;\n$$",
  "plpgsql_call-10.sql": "DO\nLANGUAGE plpgsql\n$$\nDECLARE\n    x constant int := 3;\n    y int := 4;\nBEGIN\n    CALL test_proc6(2, x, y);  -- error because x is constant\nEND;\n$$",
  "plpgsql_call-11.sql": "DO\nLANGUAGE plpgsql\n$$\nDECLARE\n    x int := 3;\n    y int := 4;\nBEGIN\n    FOR i IN 1..5 LOOP\n        CALL test_proc6(i, x, y);\n        RAISE INFO 'x = %, y = %', x, y;\n    END LOOP;\nEND;\n$$",
  "plpgsql_call-12.sql": "-- recursive with output arguments\n\nCREATE PROCEDURE test_proc7(x int, INOUT a int, INOUT b numeric)\nLANGUAGE plpgsql\nAS $$\nBEGIN\nIF x > 1 THEN\n    a := x / 10;\n    b := x / 2;\n    CALL test_proc7(b::int, a, b);\nEND IF;\nEND;\n$$",
  "plpgsql_call-13.sql": "-- inner COMMIT with output arguments\n\nCREATE PROCEDURE test_proc7c(x int, INOUT a int, INOUT b numeric)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n  a := x / 10;\n  b := x / 2;\n  COMMIT;\nEND;\n$$",
  "plpgsql_call-14.sql": "CREATE PROCEDURE test_proc7cc(_x int)\nLANGUAGE plpgsql\nAS $$\nDECLARE _a int; _b numeric;\nBEGIN\n  CALL test_proc7c(_x, _a, _b);\n  RAISE NOTICE '_x: %,_a: %, _b: %', _x, _a, _b;\nEND\n$$",
  "plpgsql_call-15.sql": "-- named parameters and defaults\n\nCREATE PROCEDURE test_proc8a(INOUT a int, INOUT b int)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n  RAISE NOTICE 'a: %, b: %', a, b;\n  a := a * 10;\n  b := b + 10;\nEND;\n$$",
  "plpgsql_call-16.sql": "DO $$\nDECLARE _a int; _b int;\nBEGIN\n  _a := 10; _b := 30;\n  CALL test_proc8a(_a, _b);\n  RAISE NOTICE '_a: %, _b: %', _a, _b;\n  CALL test_proc8a(b => _b, a => _a);\n  RAISE NOTICE '_a: %, _b: %', _a, _b;\nEND\n$$",
  "plpgsql_call-17.sql": "CREATE PROCEDURE test_proc8b(INOUT a int, INOUT b int, INOUT c int)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n  RAISE NOTICE 'a: %, b: %, c: %', a, b, c;\n  a := a * 10;\n  b := b + 10;\n  c := c * -10;\nEND;\n$$",
  "plpgsql_call-18.sql": "DO $$\nDECLARE _a int; _b int; _c int;\nBEGIN\n  _a := 10; _b := 30; _c := 50;\n  CALL test_proc8b(_a, _b, _c);\n  RAISE NOTICE '_a: %, _b: %, _c: %', _a, _b, _c;\n  CALL test_proc8b(_a, c => _c, b => _b);\n  RAISE NOTICE '_a: %, _b: %, _c: %', _a, _b, _c;\nEND\n$$",
  "plpgsql_call-19.sql": "CREATE PROCEDURE test_proc8c(INOUT a int, INOUT b int, INOUT c int DEFAULT 11)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n  RAISE NOTICE 'a: %, b: %, c: %', a, b, c;\n  a := a * 10;\n  b := b + 10;\n  c := c * -10;\nEND;\n$$",
  "plpgsql_call-20.sql": "DO $$\nDECLARE _a int; _b int; _c int;\nBEGIN\n  _a := 10; _b := 30; _c := 50;\n  CALL test_proc8c(_a, _b, _c);\n  RAISE NOTICE '_a: %, _b: %, _c: %', _a, _b, _c;\n  _a := 10; _b := 30; _c := 50;\n  CALL test_proc8c(_a, c => _c, b => _b);\n  RAISE NOTICE '_a: %, _b: %, _c: %', _a, _b, _c;\n  _a := 10; _b := 30; _c := 50;\n  CALL test_proc8c(c => _c, b => _b, a => _a);\n  RAISE NOTICE '_a: %, _b: %, _c: %', _a, _b, _c;\nEND\n$$",
  "plpgsql_call-21.sql": "DO $$\nDECLARE _a int; _b int; _c int;\nBEGIN\n  _a := 10; _b := 30; _c := 50;\n  CALL test_proc8c(_a, _b);  -- fail, no output argument for c\n  RAISE NOTICE '_a: %, _b: %, _c: %', _a, _b, _c;\nEND\n$$",
  "plpgsql_call-22.sql": "DO $$\nDECLARE _a int; _b int; _c int;\nBEGIN\n  _a := 10; _b := 30; _c := 50;\n  CALL test_proc8c(_a, b => _b);  -- fail, no output argument for c\n  RAISE NOTICE '_a: %, _b: %, _c: %', _a, _b, _c;\nEND\n$$",
  "plpgsql_call-23.sql": "-- OUT parameters\n\nCREATE PROCEDURE test_proc9(IN a int, OUT b int)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n  RAISE NOTICE 'a: %, b: %', a, b;\n  b := a * 2;\nEND;\n$$",
  "plpgsql_call-24.sql": "DO $$\nDECLARE _a int; _b int;\nBEGIN\n  _a := 10; _b := 30;\n  CALL test_proc9(_a, _b);\n  RAISE NOTICE '_a: %, _b: %', _a, _b;\nEND\n$$",
  "plpgsql_call-25.sql": "CREATE PROCEDURE test_proc10(IN a int, OUT b int, IN c int DEFAULT 11)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n  RAISE NOTICE 'a: %, b: %, c: %', a, b, c;\n  b := a - c;\nEND;\n$$",
  "plpgsql_call-26.sql": "DO $$\nDECLARE _a int; _b int; _c int;\nBEGIN\n  _a := 10; _b := 30; _c := 7;\n  CALL test_proc10(_a, _b, _c);\n  RAISE NOTICE '_a: %, _b: %, _c: %', _a, _b, _c;\n\n  _a := 10; _b := 30; _c := 7;\n  CALL test_proc10(_a, _b, c => _c);\n  RAISE NOTICE '_a: %, _b: %, _c: %', _a, _b, _c;\n\n  _a := 10; _b := 30; _c := 7;\n  CALL test_proc10(a => _a, b => _b, c => _c);\n  RAISE NOTICE '_a: %, _b: %, _c: %', _a, _b, _c;\n\n  _a := 10; _b := 30; _c := 7;\n  CALL test_proc10(_a, c => _c, b => _b);\n  RAISE NOTICE '_a: %, _b: %, _c: %', _a, _b, _c;\n\n  _a := 10; _b := 30; _c := 7;\n  CALL test_proc10(_a, _b);\n  RAISE NOTICE '_a: %, _b: %, _c: %', _a, _b, _c;\n\n  _a := 10; _b := 30; _c := 7;\n  CALL test_proc10(_a, b => _b);\n  RAISE NOTICE '_a: %, _b: %, _c: %', _a, _b, _c;\n\n  _a := 10; _b := 30; _c := 7;\n  CALL test_proc10(b => _b, a => _a);\n  RAISE NOTICE '_a: %, _b: %, _c: %', _a, _b, _c;\nEND\n$$",
  "plpgsql_call-27.sql": "-- OUT + VARIADIC\n\nCREATE PROCEDURE test_proc11(a OUT int, VARIADIC b int[])\nLANGUAGE plpgsql\nAS $$\nBEGIN\n  RAISE NOTICE 'a: %, b: %', a, b;\n  a := b[1] + b[2];\nEND;\n$$",
  "plpgsql_call-28.sql": "DO $$\nDECLARE _a int; _b int; _c int;\nBEGIN\n  _a := 10; _b := 30; _c := 7;\n  CALL test_proc11(_a, _b, _c);\n  RAISE NOTICE '_a: %, _b: %, _c: %', _a, _b, _c;\nEND\n$$",
  "plpgsql_call-29.sql": "-- polymorphic OUT arguments\n\nCREATE PROCEDURE test_proc12(a anyelement, OUT b anyelement, OUT c anyarray)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n  RAISE NOTICE 'a: %', a;\n  b := a;\n  c := array[a];\nEND;\n$$",
  "plpgsql_call-30.sql": "DO $$\nDECLARE _a int; _b int; _c int[];\nBEGIN\n  _a := 10;\n  CALL test_proc12(_a, _b, _c);\n  RAISE NOTICE '_a: %, _b: %, _c: %', _a, _b, _c;\nEND\n$$",
  "plpgsql_call-31.sql": "DO $$\nDECLARE _a int; _b int; _c text[];\nBEGIN\n  _a := 10;\n  CALL test_proc12(_a, _b, _c);  -- error\n  RAISE NOTICE '_a: %, _b: %, _c: %', _a, _b, _c;\nEND\n$$",
  "plpgsql_call-32.sql": "CREATE FUNCTION triggerfunc1() RETURNS trigger\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    z int := 0;\nBEGIN\n    CALL test_proc6(2, NEW.a, NEW.a);\n    RETURN NEW;\nEND;\n$$",
  "plpgsql_call-33.sql": "-- more checks for named-parameter handling\n\nCREATE PROCEDURE p1(v_cnt int, v_Text inout text = NULL)\nAS $$\nBEGIN\n  v_Text := 'v_cnt = ' || v_cnt;\nEND\n$$ LANGUAGE plpgsql",
  "plpgsql_call-34.sql": "DO $$\nDECLARE\n  v_Text text;\n  v_cnt  integer := 42;\nBEGIN\n  CALL p1(v_cnt := v_cnt);  -- error, must supply something for v_Text\n  RAISE NOTICE '%', v_Text;\nEND;\n$$",
  "plpgsql_call-35.sql": "DO $$\nDECLARE\n  v_Text text;\n  v_cnt  integer := 42;\nBEGIN\n  CALL p1(v_cnt := v_cnt, v_Text := v_Text);\n  RAISE NOTICE '%', v_Text;\nEND;\n$$",
  "plpgsql_call-36.sql": "DO $$\nDECLARE\n  v_Text text;\nBEGIN\n  CALL p1(10, v_Text := v_Text);\n  RAISE NOTICE '%', v_Text;\nEND;\n$$",
  "plpgsql_call-37.sql": "DO $$\nDECLARE\n  v_Text text;\n  v_cnt  integer;\nBEGIN\n  CALL p1(v_Text := v_Text, v_cnt := v_cnt);\n  RAISE NOTICE '%', v_Text;\nEND;\n$$",
  "plpgsql_call-38.sql": "-- check that we detect change of dependencies in CALL\n-- atomic and non-atomic call sites used to do this differently, so check both\n\nCREATE PROCEDURE inner_p (f1 int)\nAS $$\nBEGIN\n  RAISE NOTICE 'inner_p(%)', f1;\nEND\n$$ LANGUAGE plpgsql",
  "plpgsql_call-39.sql": "CREATE PROCEDURE outer_p (f1 int)\nAS $$\nBEGIN\n  RAISE NOTICE 'outer_p(%)', f1;\n  CALL inner_p(f(f1));\nEND\n$$ LANGUAGE plpgsql",
  "plpgsql_call-40.sql": "CREATE FUNCTION outer_f (f1 int) RETURNS void\nAS $$\nBEGIN\n  RAISE NOTICE 'outer_f(%)', f1;\n  CALL inner_p(f(f1));\nEND\n$$ LANGUAGE plpgsql",
  "plpgsql_call-41.sql": "CREATE FUNCTION f_get_x () RETURNS int\nAS $$\nDECLARE l_result int;\nBEGIN\n  SELECT x INTO l_result FROM t_test;\n  RETURN l_result;\nEND\n$$ LANGUAGE plpgsql STABLE",
  "plpgsql_call-42.sql": "CREATE PROCEDURE f_print_x (x int)\nAS $$\nBEGIN\n  RAISE NOTICE 'f_print_x(%)', x;\nEND\n$$ LANGUAGE plpgsql",
  "plpgsql_call-43.sql": "-- test in non-atomic context\nDO $$\nBEGIN\n  UPDATE t_test SET x = x + 1;\n  RAISE NOTICE 'f_get_x(%)', f_get_x();\n  CALL f_print_x(f_get_x());\n  UPDATE t_test SET x = x + 1;\n  RAISE NOTICE 'f_get_x(%)', f_get_x();\n  CALL f_print_x(f_get_x());\n  ROLLBACK;\nEND\n$$",
  "plpgsql_call-44.sql": "-- test in non-atomic context, except exception block is locally atomic\nDO $$\nBEGIN\n BEGIN\n  UPDATE t_test SET x = x + 1;\n  RAISE NOTICE 'f_get_x(%)', f_get_x();\n  CALL f_print_x(f_get_x());\n  UPDATE t_test SET x = x + 1;\n  RAISE NOTICE 'f_get_x(%)', f_get_x();\n  CALL f_print_x(f_get_x());\n EXCEPTION WHEN division_by_zero THEN\n   RAISE NOTICE '%', SQLERRM;\n END;\n  ROLLBACK;\nEND\n$$",
  "plpgsql_call-45.sql": "DO $$\nBEGIN\n  UPDATE t_test SET x = x + 1;\n  RAISE NOTICE 'f_get_x(%)', f_get_x();\n  CALL f_print_x(f_get_x());\n  UPDATE t_test SET x = x + 1;\n  RAISE NOTICE 'f_get_x(%)', f_get_x();\n  CALL f_print_x(f_get_x());\nEND\n$$",
  "plpgsql_cache-1.sql": "-- check behavior with changes in a record rowtype\ncreate function show_result_type(text) returns text language plpgsql as\n$$\n    declare\n        r record;\n        t text;\n    begin\n        execute $1 into r;\n        select pg_typeof(r.a) into t;\n        return format('type %s value %s', t, r.a::text);\n    end;\n$$",
  "plpgsql_array-1.sql": "do $$ declare a int[];\nbegin a := array[1,2]; a[3] := 4; raise notice 'a = %', a; end$$",
  "plpgsql_array-2.sql": "do $$ declare a int[];\nbegin a[3] := 4; raise notice 'a = %', a; end$$",
  "plpgsql_array-3.sql": "do $$ declare a int[];\nbegin a[1][4] := 4; raise notice 'a = %', a; end$$",
  "plpgsql_array-4.sql": "do $$ declare a int[];\nbegin a[1] := 23::text; raise notice 'a = %', a; end$$",
  "plpgsql_array-5.sql": "-- lax typing\n\ndo $$ declare a int[];\nbegin a := array[1,2]; a[2:3] := array[3,4]; raise notice 'a = %', a; end$$",
  "plpgsql_array-6.sql": "do $$ declare a int[];\nbegin a := array[1,2]; a[2] := a[2] + 1; raise notice 'a = %', a; end$$",
  "plpgsql_array-7.sql": "do $$ declare a int[];\nbegin a[1:2] := array[3,4]; raise notice 'a = %', a; end$$",
  "plpgsql_array-8.sql": "do $$ declare a int[];\nbegin a[1:2] := 4; raise notice 'a = %', a; end$$",
  "plpgsql_array-9.sql": "-- error\n\ndo $$ declare a complex[];\nbegin a[1] := (1,2); a[1].i := 11; raise notice 'a = %', a; end$$",
  "plpgsql_array-10.sql": "do $$ declare a complex[];\nbegin a[1].i := 11; raise notice 'a = %, a[1].i = %', a, a[1].i; end$$",
  "plpgsql_array-11.sql": "-- perhaps this ought to work, but for now it doesn't:\ndo $$ declare a complex[];\nbegin a[1:2].i := array[11,12]; raise notice 'a = %', a; end$$",
  "plpgsql_array-12.sql": "do $$ declare a int[];\nbegin a := array_agg(x) from (values(1),(2),(3)) v(x); raise notice 'a = %', a; end$$",
  "plpgsql_array-13.sql": "do $$ declare a int[];\nbegin a := f1 from onecol; raise notice 'a = %', a; end$$",
  "plpgsql_array-14.sql": "do $$ declare a int[];\nbegin a := * from onecol for update; raise notice 'a = %', a; end$$",
  "plpgsql_array-15.sql": "-- error cases:\n\ndo $$ declare a int[];\nbegin a := from onecol; raise notice 'a = %', a; end$$",
  "plpgsql_array-16.sql": "do $$ declare a int[];\nbegin a := f1, f1 from onecol; raise notice 'a = %', a; end$$",
  "plpgsql_array-17.sql": "do $$ declare a int[];\nbegin a := f1 from onecol; raise notice 'a = %', a; end$$",
  "plpgsql_array-18.sql": "do $$ declare a int[];\nbegin a := f1 from onecol limit 1; raise notice 'a = %', a; end$$",
  "plpgsql_array-19.sql": "do $$ declare a real;\nbegin a[1] := 2; raise notice 'a = %', a; end$$",
  "plpgsql_array-20.sql": "--\n-- test of %type[] and %rowtype[] syntax\n--\n\n-- check supported syntax\ndo $$\ndeclare\n  v int;\n  v1 v%type;\n  v2 v%type[];\n  v3 v%type[1];\n  v4 v%type[][];\n  v5 v%type[1][3];\n  v6 v%type array;\n  v7 v%type array[];\n  v8 v%type array[1];\n  v9 v%type array[1][1];\n  v10 pg_catalog.pg_class%rowtype[];\nbegin\n  raise notice '%', pg_typeof(v1);\n  raise notice '%', pg_typeof(v2);\n  raise notice '%', pg_typeof(v3);\n  raise notice '%', pg_typeof(v4);\n  raise notice '%', pg_typeof(v5);\n  raise notice '%', pg_typeof(v6);\n  raise notice '%', pg_typeof(v7);\n  raise notice '%', pg_typeof(v8);\n  raise notice '%', pg_typeof(v9);\n  raise notice '%', pg_typeof(v10);\nend;\n$$",
  "plpgsql_array-21.sql": "-- some types don't support arrays\ndo $$\ndeclare\n  v pg_node_tree;\n  v1 v%type[];\nbegin\nend;\n$$",
  "plpgsql_array-22.sql": "-- check functionality\ndo $$\ndeclare\n  v1 int;\n  v2 varchar;\n  a1 v1%type[];\n  a2 v2%type[];\nbegin\n  v1 := 10;\n  v2 := 'Hi';\n  a1 := array[v1,v1];\n  a2 := array[v2,v2];\n  raise notice '% %', a1, a2;\nend;\n$$",
  "plpgsql_array-23.sql": "do $$\ndeclare tg array_test_table%rowtype[];\nbegin\n  tg := array(select array_test_table from array_test_table);\n  raise notice '%', tg;\n  tg := array(select row(a,b) from array_test_table);\n  raise notice '%', tg;\nend;\n$$"
}