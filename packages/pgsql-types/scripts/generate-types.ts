import { runtimeSchema, NodeSpec, FieldSpec } from '../../utils/src/runtime-schema';
import * as fs from 'fs';
import * as path from 'path';

interface FieldMetadata {
  nullable: boolean;
  tags: string[];
  isArray: boolean;
}

interface NodeFieldMetadata {
  [fieldName: string]: FieldMetadata;
}

interface AllFieldMetadata {
  [nodeName: string]: NodeFieldMetadata;
}

const schemaMap = new Map<string, NodeSpec>(
  runtimeSchema.map((spec: NodeSpec) => [spec.name, spec])
);

const primitiveTypeMap: Record<string, string> = {
  'string': 'string',
  'bool': 'boolean',
  'int32': 'number',
  'int64': 'number',
  'uint32': 'number',
  'uint64': 'number',
  'float': 'number',
  'double': 'number',
  'bytes': 'Uint8Array',
};

function isPrimitiveType(type: string): boolean {
  return type in primitiveTypeMap;
}

function isEnumType(type: string): boolean {
  return !isPrimitiveType(type) && !schemaMap.has(type) && type !== 'Node';
}

function getTsType(type: string): string {
  return primitiveTypeMap[type] || type;
}

function collectEnumTypes(): Set<string> {
  const enumTypes = new Set<string>();
  for (const nodeSpec of runtimeSchema) {
    for (const field of nodeSpec.fields) {
      if (isEnumType(field.type)) {
        enumTypes.add(field.type);
      }
    }
  }
  return enumTypes;
}

function generateWrappedUnion(tags: string[]): string {
  if (tags.length === 0) {
    return 'Node';
  }
  
  const sortedTags = [...tags].sort();
  return sortedTags.map(tag => `{ ${tag}: ${tag} }`).join(' | ');
}

function generateTypeAlias(nodeName: string, fieldName: string, tags: string[]): string {
  const aliasName = `${nodeName}_${fieldName}`;
  const union = generateWrappedUnion(tags);
  return `export type ${aliasName} = ${union};`;
}

function generateInterface(
  nodeSpec: NodeSpec,
  fieldMetadata: NodeFieldMetadata | undefined
): string {
  const lines: string[] = [];
  lines.push(`export interface ${nodeSpec.name} {`);
  
  for (const field of nodeSpec.fields) {
    const tsType = getFieldType(nodeSpec.name, field, fieldMetadata);
    const optional = field.optional ? '?' : '';
    lines.push(`  ${field.name}${optional}: ${tsType};`);
  }
  
  lines.push('}');
  return lines.join('\n');
}

function getFieldType(
  nodeName: string,
  field: FieldSpec,
  fieldMetadata: NodeFieldMetadata | undefined
): string {
  let baseType: string;
  
  if (field.type === 'Node') {
    const meta = fieldMetadata?.[field.name];
    if (meta && meta.tags.length > 0) {
      baseType = `${nodeName}_${field.name}`;
    } else {
      baseType = 'Node';
    }
  } else if (isPrimitiveType(field.type)) {
    baseType = getTsType(field.type);
  } else {
    if (schemaMap.has(field.type)) {
      baseType = `{ ${field.type}: ${field.type} }`;
    } else {
      baseType = field.type;
    }
  }
  
  if (field.isArray) {
    if (baseType.includes('|') || baseType.includes('{')) {
      return `(${baseType})[]`;
    }
    return `${baseType}[]`;
  }
  
  return baseType;
}

function generateTypes(metadata: AllFieldMetadata): string {
  const lines: string[] = [];
  
  lines.push('/**');
  lines.push(' * This file was automatically generated by pgsql-types.');
  lines.push(' * DO NOT MODIFY IT BY HAND.');
  lines.push(' * ');
  lines.push(' * These types provide narrowed Node unions based on actual usage');
  lines.push(' * patterns discovered by parsing SQL fixtures.');
  lines.push(' */');
  lines.push('');
  
  const enumTypes = collectEnumTypes();
  const sortedEnums = [...enumTypes].sort();
  
  lines.push("import type { Node } from '@pgsql/types';");
  if (sortedEnums.length > 0) {
    lines.push(`import { ${sortedEnums.join(', ')} } from '@pgsql/enums';`);
  }
  lines.push("export type { Node } from '@pgsql/types';");
  lines.push("export * from '@pgsql/enums';");
  lines.push('');
  
  const typeAliases: string[] = [];
  for (const nodeName of Object.keys(metadata).sort()) {
    const nodeMetadata = metadata[nodeName];
    for (const fieldName of Object.keys(nodeMetadata).sort()) {
      const fieldMeta = nodeMetadata[fieldName];
      if (fieldMeta.tags.length > 0) {
        typeAliases.push(generateTypeAlias(nodeName, fieldName, fieldMeta.tags));
      }
    }
  }
  
  if (typeAliases.length > 0) {
    lines.push('// Narrowed type aliases for Node-typed fields');
    lines.push(typeAliases.join('\n'));
    lines.push('');
  }
  
  lines.push('// Interfaces with narrowed Node types');
  for (const nodeSpec of runtimeSchema) {
    const nodeMetadata = metadata[nodeSpec.name];
    lines.push(generateInterface(nodeSpec, nodeMetadata));
    lines.push('');
  }
  
  return lines.join('\n');
}

async function main() {
  const metadataPath = path.resolve(__dirname, '../src/field-metadata.json');
  const outputPath = path.resolve(__dirname, '../src/types.ts');
  
  if (!fs.existsSync(metadataPath)) {
    console.error('Field metadata not found. Run "npm run infer" first.');
    process.exit(1);
  }
  
  const metadata: AllFieldMetadata = JSON.parse(fs.readFileSync(metadataPath, 'utf-8'));
  
  console.log('Generating narrowed types...');
  const typesContent = generateTypes(metadata);
  
  fs.writeFileSync(outputPath, typesContent);
  console.log(`Wrote narrowed types to ${outputPath}`);
  
  let totalAliases = 0;
  for (const nodeName of Object.keys(metadata)) {
    for (const fieldName of Object.keys(metadata[nodeName])) {
      if (metadata[nodeName][fieldName].tags.length > 0) {
        totalAliases++;
      }
    }
  }
  
  console.log(`Generated ${totalAliases} narrowed type aliases`);
}

main().catch(console.error);
